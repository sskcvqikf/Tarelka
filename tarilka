#!/usr/bin/env lua

Yaml = require('yaml')

HOME = os.getenv("HOME")
CONFIG_ROOT = HOME .. "/.config/tarilka"

function SplitMappings(full_mapping)
  local ret = {}
  for s in string.gmatch(full_mapping, "([^:]+)") do
    table.insert(ret, s)
  end
  assert(#ret == 2, "Mapping " .. full_mapping .. " is invalid")
  return ret
end

function GetOutputOfShellCommand(command)
  local handle = assert(io.popen(command))
  local ret = assert(handle:read("a"))
  assert(handle:close())
  ret = string.gsub(ret, '^%s+', '')
  ret = string.gsub(ret, '%s+$', '')
  ret = string.gsub(ret, '[\n\r]+', ' ')
  return ret
end

function RunShellCommand(command)
  return os.execute(command)
end

function CheckIfRoot()
  return assert(GetOutputOfShellCommand("id -u")) == "0"
end

function MustNotBeRoot(f)
  return function(...)
    assert(not CheckIfRoot(), "DONT RUN THIS AS ROOT!!!")
    return f(...)
  end
end

function GetConfig(path, env)
  local handle = assert(io.open(path))
  local text = assert(handle:read("a"))
  assert(handle:close())
  local conf = Yaml.eval(text)
  local ret = assert(conf[env], "Config not found for given environment")
  return ret
end

function CreateImage(name, path_to_dockerfile)
  local command = "docker build -t " .. name .. " " .. path_to_dockerfile
  local _ = assert(RunShellCommand(command))
end

function RunContainer(name, host_port, docker_port, mappings)
  local mount_string = ""
  for _, mapping in ipairs(mappings) do
    mount_string = mount_string .. " --mount type=bind,source=" .. mapping[1] .. ",target=" .. mapping[2]
  end

  local port_string = " -p" .. host_port .. ":" .. docker_port

  local command = "docker run -d --rm" .. mount_string ..
                  " --cap-add sys_ptrace" .. port_string ..
                  " --name " .. name .. " " .. name
  local _ = assert(RunShellCommand(command))
end

function StopContainer(name)
  local command = "docker stop " .. name
  local _ = assert(RunShellCommand(command))
end

function LoginToContainer(name, shell)
  local command = "docker exec -it " .. name .. " " .. shell
  local _ = assert(RunShellCommand(command))
end

function HandleBuild(env, _, _)
  local path_to_dockerfile = CONFIG_ROOT .. "/docker/" .. env
  return CreateImage(env, path_to_dockerfile)
end

function HandleStart(env, _, config)
  local host_port = assert(config["host-port"], "Must be specified in config")
  local docker_port = assert(config["docker-port"], "Must be specified in config")
  local raw_mappings = config["directory-mappings"]
  local mappings = {}
  for _, raw_mapping in ipairs(raw_mappings) do
    table.insert(mappings, SplitMappings(raw_mapping))
  end
  return RunContainer(env, host_port, docker_port, mappings)
end

function HandleStop(env, _, _)
  return StopContainer(env)
end

function HandleLogin(env, _, config)
  local shell = assert(config["shell"], "Must be specified in config")
  return LoginToContainer(env, shell)
end

COMMANDS =
{
  BUILD = HandleBuild,
  START = HandleStart,
  STOP = HandleStop,
  LOGIN = HandleLogin,
}

COMMANDS_MAP =
{
  build = COMMANDS.BUILD,
  start = COMMANDS.START,
  stop = COMMANDS.STOP,
  login = COMMANDS.LOGIN,
}

function GetCommand(command)
  return assert(COMMANDS_MAP[command], "Command " .. command " not found")
end

function GetCommandArguments(args)
  local ret = {table.unpack(args, 3)}
  return ret
end

function GetRequiredArgs(args)
  local command = assert(args[1], "You MUST provide a command name")
  local env = assert(args[2], "You MUST provide an environment name")
  return command, env
end

function Main()
  local command, env = GetRequiredArgs(arg)

  local config_path = CONFIG_ROOT .. "/tarilka.yaml"
  local config = GetConfig(config_path, env)

  local args = GetCommandArguments(arg)
  local handler = COMMANDS_MAP[command]

  handler(env, args, config)
end

Main = MustNotBeRoot(Main)

Main()
